#include <Arduino.h>
#include <Wire.h>
#include <driver/rtc_io.h>
#include <esp_wifi.h>

#include "BoxBeep.h"
#include "BoxData.h"
#include "BoxDisplay.h"
#include "BoxTime.h"
#include "ButtonHandler.h"
#include "SensorScd041.h"
#include "measurement/Measurement.h"

gpio_num_t PIN_A = GPIO_NUM_11;
// gpio_num_t PIN_B = GPIO_NUM_12;
// gpio_num_t PIN_C = GPIO_NUM_6;

typedef enum {
    CYCLE_BOOT,  // boot
    CYCLE_MAIN,  // measure or render
    CYCLE_POST
} cycle_mode_t;

// TODO :: move to button handlers
const int PIN_ABC_BITMASK = 1ULL << PIN_A;  // | 1ULL << PIN_B | 1ULL << PIN_C;
const int32_t SECONDS_BOOT_BUFFER = 10;
const int32_t SECONDS_WAIT__NEVER = 60 * 60 * 24;
const int32_t SECONDS_WAIT_MEASURE_POST = 5;
const int32_t SECONDS_WAIT_DISPLAY_POST = 2;
const int32_t MICROSECONDS_PER_SECOND = 1000000;  // 1 second
const int32_t SECONDS_TIME_RTC000 = 341192523;

RTC_DATA_ATTR cycle_mode_t cycleModeMeasure = CYCLE_BOOT;
RTC_DATA_ATTR cycle_mode_t cycleModeDisplay = CYCLE_BOOT;
RTC_DATA_ATTR MeasurementCo2 measurements[60];
RTC_DATA_ATTR int32_t nextMeasureIndex = 0;  // the index of the next measurement
RTC_DATA_ATTR int32_t nextDisplayIndex = 0;  // the index of the next renderable measurement
RTC_DATA_ATTR int32_t secondsCycleBase;

ButtonHandler buttonHandlerA(GPIO_NUM_11);
BoxBeep boxBeep;
BoxTime boxTime;
BoxData boxData;
SensorScd041 sensorScd041;
BoxDisplay boxDisplay;
std::function<void(void)> displayFunc = nullptr;

int32_t getMeasureNextSeconds() {
    return secondsCycleBase + nextMeasureIndex * 60;  // add one to index to be one measurement ahead
}

int32_t getMeasureWaitSeconds() {
    return getMeasureNextSeconds() - boxTime.getDate().secondstime();
}

/**
 * think about a "heartbeat" pattern, where there could be a set of actions around specific, "fixed" points in time
 *
 * -- measure (heartbeat)  , power up I2C
 * -- readval (measure + 5), power down I2C
 * ------------------------
 * -- display (readval)    , power up display
 * -- depower (display + 2), power down display
 *
 * after completion of every heartbeat the next heartbeat could be assembled
 * maybe the same pattern can be used to schedule user-interaction (i.e. toggling display state, then redrawing)
 * then, when the device wakes up, it has to pick actions (even if already late in schedule) until a relevant sleep time is encountered
 */

void setup() {
    pinMode(GPIO_NUM_16, OUTPUT);
    digitalWrite(GPIO_NUM_16, LOW);

    // turn on I2C power
    pinMode(I2C_POWER, OUTPUT);
    digitalWrite(I2C_POWER, HIGH);

    Wire.begin();
    boxBeep.begin();
    boxBeep.setPixelColor(COLOR__YELLOW);
    boxTime.begin();
    // while (boxTime.getDate().secondstime() == SECONDS_TIME_RTC000) {
    //     delay(5);
    // }
    delay(50);  // find out why this is needed and if there could be a more efficient way to wait only for as long as neededd

    // uint16_t totalSerialWait = 0;
    // Serial.begin(115200);
    // while (!Serial) {
    //     delay(10);
    //     totalSerialWait += 10;
    // }

    if (cycleModeMeasure == CYCLE_BOOT) {
        boxBeep.setPixelColor(COLOR_MAGENTA);
        delay(1000);  // boxTime appears to take some time to initialize
        // secondsCycleBase = boxTime.getDate().secondstime();
        // secondsCycleBase = secondsCycleBase + 60 + SECONDS_BOOT_BUFFER - (secondsCycleBase + SECONDS_BOOT_BUFFER) % 60;  // first full minute after boot in secondstime
        secondsCycleBase = boxTime.getDate().secondstime() + 15;
        boxData.begin();
        cycleModeMeasure = CYCLE_MAIN;
        cycleModeDisplay = CYCLE_MAIN;
        boxBeep.setPixelColor(COLOR__YELLOW);
    }

    sensorScd041.begin();
    buttonHandlerA.begin();

    /**
     * check for button actions, TODO :: move as much code as possible to button handlers
     */

    esp_sleep_wakeup_cause_t wakeupReason = esp_sleep_get_wakeup_cause();
    if (wakeupReason == ESP_SLEEP_WAKEUP_EXT1) {
        uint64_t wakeupStatus = esp_sleep_get_ext1_wakeup_status();
        gpio_num_t wakeupPin = (gpio_num_t)(log(wakeupStatus) / log(2));
        while (wakeupPin == PIN_A && digitalRead(PIN_A) == LOW) {  // wait for LONG_PRESS_DURATION max
            boxBeep.setPixelColor(COLOR_MAGENTA);
            delay(100);
        }
    }

    esp_sleep_disable_wakeup_source(ESP_SLEEP_WAKEUP_ALL);

    if (cycleModeDisplay == CYCLE_POST) {
        boxBeep.setPixelColor(COLOR____CYAN);
        boxDisplay.hibernate(true);
        boxBeep.setPixelColor(COLOR__YELLOW);
        cycleModeDisplay = CYCLE_MAIN;
    }

    int32_t reducedWaitSeconds = SECONDS_WAIT__NEVER;
    if (cycleModeMeasure == CYCLE_POST) {
        // measure and store
        MeasurementCo2 measurementCo2 = sensorScd041.readval();
        int currMeasureIndex = nextMeasureIndex - 1;  // add 60 to prevent access to negative indices
        measurements[currMeasureIndex % 60] = measurementCo2;

        // turn off sensor and I2C power
        sensorScd041.powerDown();
        pinMode(I2C_POWER, OUTPUT);
        digitalWrite(I2C_POWER, LOW);
        gpio_hold_dis((gpio_num_t)I2C_POWER);

        // switch away from CYCLE_POST
        cycleModeMeasure = CYCLE_MAIN;

        // check for display refresh
        if (currMeasureIndex == nextDisplayIndex) {
            boxBeep.setPixelColor(COLOR_____RED);
            String value1 = currMeasureIndex >= 2 ? String(measurements[(currMeasureIndex + 58) % 60].co2) : "NA";
            String value2 = currMeasureIndex >= 1 ? String(measurements[(currMeasureIndex + 59) % 60].co2) : "NA";
            String value3 = currMeasureIndex >= 0 ? String(measurements[(currMeasureIndex + 60) % 60].co2) : "NA";
            displayFunc = [=]() -> void { boxDisplay.renderTest(value1, value2, value3); };
            nextDisplayIndex += 3;
            boxBeep.setPixelColor(COLOR__YELLOW);
            cycleModeDisplay = CYCLE_POST;
            reducedWaitSeconds = min(reducedWaitSeconds, SECONDS_WAIT_DISPLAY_POST);  // wake up after 2 seconds to hibernate the display
        }
    }

    int32_t measureWaitSeconds = getMeasureWaitSeconds();
    if (measureWaitSeconds <= 1) {
        sensorScd041.powerUp();
        sensorScd041.measure();
        nextMeasureIndex++;
        // hold I2C power so the sensors are still up while
        gpio_hold_en((gpio_num_t)I2C_POWER);
        cycleModeMeasure = CYCLE_POST;
        reducedWaitSeconds = min(reducedWaitSeconds, SECONDS_WAIT_MEASURE_POST);
    }

    buttonHandlerA.prepareSleep();
    boxBeep.prepareSleep();

    int32_t waitSeconds = min(getMeasureWaitSeconds(), reducedWaitSeconds);
    esp_sleep_enable_ext1_wakeup(PIN_ABC_BITMASK, ESP_EXT1_WAKEUP_ANY_LOW);
    esp_sleep_enable_timer_wakeup(waitSeconds * MICROSECONDS_PER_SECOND);

    // Serial.flush();
    // Serial.end();
    boxBeep.setPixelColor(COLOR____BLUE);
    digitalWrite(GPIO_NUM_16, HIGH);

    if (displayFunc) {
        displayFunc();
    }

    Wire.end();           // https://github.com/espressif/arduino-esp32/issues/3363
    pinMode(SDA, INPUT);  // needed because Wire.end() enables pullups, power Saving
    pinMode(SCL, INPUT);

    esp_deep_sleep_start();
}

void loop() {
    // maybe some code here, i.e. when wifi is on
    // TODO :: read up on low power wifi
    delay(2000);
}
